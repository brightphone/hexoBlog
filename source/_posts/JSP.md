---
layout: post
title: "JSP/Servlet简介"
date: 2020-05-05 12:00:00
comments: true
catagories: language
tags: [JavaEE]
---
JSP(Java Server Page)和 Servlet是JavaEE规范的两个基本成员，它们是Java Web开发的重点知识，也是Java EE开发的基础知识。JSP和Servlet的本质是一样的，因为JSP最终必须编译成servlet才能运行，或者说JSP只是生成Servlet的“草稿”文件。
<!--more-->
现在JSP主要是表现层技术，不再承担业务逻辑组件及持久层组件的责任。
JSP相关技术：Servlet，Listener，Filter以及自定义标签
# Web应用和Web.xml文件
下面徒手建立Web应用.
- 建立一个文件夹，取名为webDemo
- 建立一个WEB-INF文件夹（注意大小写）
- 在WEB-INF文件夹里创建web.xml文件文件内容如下
```
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
         version="4.0">
</web-app>
```
- 在WEB-INF文件夹里新建classes和lib文件夹，这两个文件夹的作用完全相同：都是用于保存web应用所需要的java类文件，区别是classes保存单个*.class文件，lib保存打包后的JAR文件。
- 在webDemo文件夹里创建一个jsp文件，内容如下
```
<%@ page contentType="text/html;charset=UTF-8" language="java" errorPage="" %>
<html>
<head>
    <title>WelCome</title>
</head>
<body>
Welcome to Java Web.
</body>
</html>
```
- 将webDemo复制到Tomcat的webapps目录下，启动tomcat，浏览器输入 http://localhose:8080/webDemo/a.jsp 即可
  
## web.xml
该文件被称为配置描述符，这个文件对Java Web应用十分重要，Servlet 2.5规范之前，每个Java Web应用都必须包含一个该文件，Servlet 3之后该文件不再是必需都，但建议保留.
2.5之前，Java Web应用的绝大部分组件都通过这个文件来配置，servlet 3之后可以通过注解来配置管理web组件。
- 配置JSP
- 配置和管理Servlet
- 配置和管理Listener
- 配置和管理Filter
- 配置标签库
- 配置JSP属性
- 配置和管理JAAS授权认证
- 配置和管理资源引用
- Web应用首页
  
Servlet 3增加了 metadata-complete属性，该属性接受true或false，当为true时，将不会加载注解配置的web组件（如Servlet，Filter，Listener等）。
### 配置首页
```
<!-- 配置web应用的首页列表>
<welcome-file-list>
    <welcome-file>index.html</welcome-file>
    <welcome-file>index.htm</welcome-file>
    <welcome-file>index.jsp</welcome-file>
</welcome-file-list>
```
上面的配置信息指定该Web应用的首页依次是index.html,index.htm和index.jsp
每个Web容器都会提供一个系统的web.xml文件，用于描述所有Web应用共同的配置属性。Tomcat是在conf路径中。
Jetty在etc中的webdefault.xml
# JSP基本原理
JSP的本质是Servlet（一个特殊的Java类），当用户向指定Servlet发送请求时，Servlet利用输出流动态生成HTML页面。
JSP通过在标准的HTML页面中嵌入java代码，静态的部分无须Java程序控制，只有那些动态的部门才使用Java脚本控制。
```
<%@ page contentType="text/html;charset=UTF-8" language="java" errorPage="" %>
<html>
<head>
    <title>WelCome</title>
</head>
<body>
Welcome to Java Web.Hello~
<br/>
<%out.println(new java.util.Date());%>
</body>
</html>
```
当启动Tomcat后，可以在...\Tomcat/work/Catalina/localhost/webDemo/org/apache/jsp目录找到
a_jsp.class和a_jsp.java文件，这两个文件都是由tomcat生成的，Tomcat根据JSP页面生成对应Servlet的Java文件和class文件.
a_jsp.java的源码如下：
```
/*
 * Generated by the Jasper component of Apache Tomcat
 * Version: Apache Tomcat/8.5.54
 * Generated at: 2020-05-28 13:02:24 UTC
 * Note: The last modified time of this file was set to
 *       the last modified time of the source file after
 *       generation to assist with modification tracking.
 */
package org.apache.jsp;

import javax.servlet.*;
import javax.servlet.http.*;
import javax.servlet.jsp.*;

public final class a_jsp extends org.apache.jasper.runtime.HttpJspBase
    implements org.apache.jasper.runtime.JspSourceDependent,
                 org.apache.jasper.runtime.JspSourceImports {

  private static final javax.servlet.jsp.JspFactory _jspxFactory =
          javax.servlet.jsp.JspFactory.getDefaultFactory();

  private static java.util.Map<java.lang.String,java.lang.Long> _jspx_dependants;

  private static final java.util.Set<java.lang.String> _jspx_imports_packages;

  private static final java.util.Set<java.lang.String> _jspx_imports_classes;

  static {
    _jspx_imports_packages = new java.util.HashSet<>();
    _jspx_imports_packages.add("javax.servlet");
    _jspx_imports_packages.add("javax.servlet.http");
    _jspx_imports_packages.add("javax.servlet.jsp");
    _jspx_imports_classes = null;
  }

  private volatile javax.el.ExpressionFactory _el_expressionfactory;
  private volatile org.apache.tomcat.InstanceManager _jsp_instancemanager;

  public java.util.Map<java.lang.String,java.lang.Long> getDependants() {
    return _jspx_dependants;
  }

  public java.util.Set<java.lang.String> getPackageImports() {
    return _jspx_imports_packages;
  }

  public java.util.Set<java.lang.String> getClassImports() {
    return _jspx_imports_classes;
  }

  public javax.el.ExpressionFactory _jsp_getExpressionFactory() {
    if (_el_expressionfactory == null) {
      synchronized (this) {
        if (_el_expressionfactory == null) {
          _el_expressionfactory = _jspxFactory.getJspApplicationContext(getServletConfig().getServletContext()).getExpressionFactory();
        }
      }
    }
    return _el_expressionfactory;
  }

  public org.apache.tomcat.InstanceManager _jsp_getInstanceManager() {
    if (_jsp_instancemanager == null) {
      synchronized (this) {
        if (_jsp_instancemanager == null) {
          _jsp_instancemanager = org.apache.jasper.runtime.InstanceManagerFactory.getInstanceManager(getServletConfig());
        }
      }
    }
    return _jsp_instancemanager;
  }

  public void _jspInit() {
  }

  public void _jspDestroy() {
  }

  public void _jspService(final javax.servlet.http.HttpServletRequest request, final javax.servlet.http.HttpServletResponse response)
      throws java.io.IOException, javax.servlet.ServletException {

    final java.lang.String _jspx_method = request.getMethod();
    if (!"GET".equals(_jspx_method) && !"POST".equals(_jspx_method) && !"HEAD".equals(_jspx_method) && !javax.servlet.DispatcherType.ERROR.equals(request.getDispatcherType())) {
      response.sendError(HttpServletResponse.SC_METHOD_NOT_ALLOWED, "JSPs only permit GET, POST or HEAD. Jasper also permits OPTIONS");
      return;
    }

    final javax.servlet.jsp.PageContext pageContext;
    javax.servlet.http.HttpSession session = null;
    final javax.servlet.ServletContext application;
    final javax.servlet.ServletConfig config;
    javax.servlet.jsp.JspWriter out = null;
    final java.lang.Object page = this;
    javax.servlet.jsp.JspWriter _jspx_out = null;
    javax.servlet.jsp.PageContext _jspx_page_context = null;


    try {
      response.setContentType("text/html;charset=UTF-8");
      pageContext = _jspxFactory.getPageContext(this, request, response,
      			"", true, 8192, true);
      _jspx_page_context = pageContext;
      application = pageContext.getServletContext();
      config = pageContext.getServletConfig();
      session = pageContext.getSession();
      out = pageContext.getOut();
      _jspx_out = out;

      out.write("\n");
      out.write("<html>\n");
      out.write("<head>\n");
      out.write("    <title>WelCome</title>\n");
      out.write("</head>\n");
      out.write("<body>\n");
      out.write("Welcome to Java Web.Hello~\n");
      out.write("<br/>\n");
out.println(new java.util.Date());
      out.write("\n");
      out.write("</body>\n");
      out.write("</html>");
    } catch (java.lang.Throwable t) {
      if (!(t instanceof javax.servlet.jsp.SkipPageException)){
        out = _jspx_out;
        if (out != null && out.getBufferSize() != 0)
          try {
            if (response.isCommitted()) {
              out.flush();
            } else {
              out.clearBuffer();
            }
          } catch (java.io.IOException e) {}
        if (_jspx_page_context != null) _jspx_page_context.handlePageException(t);
        else throw new ServletException(t);
      }
    } finally {
      _jspxFactory.releasePageContext(_jspx_page_context);
    }
  }
}
```
其实这就是一个servlet类的源代码，主要包含三个方法：
- init（）
- destroy（）
- service（）

# JSP的4种基本语法
```
<%@ page contentType="text/html;charset=UTF-8" language="java" errorPage="" %>
<html>
<head>
    <title>WelCome JSP</title>
</head>
<%! 
//声明一个整型变量
public int count;
//声明一个方法
public String info () {
    return "hello";
}
%>
<body>
Welcome to Java Web.Hello~
<br/>
<%--JSP注释内容--%>
<!-- html注释内容-->
<%out.println(new java.util.Date());%>
<%
//将count 值输出
out.println(count++);
%>
<br/>
<%=count++%>
<br/>
<%
//将info 输出
out.println(info());
%>
</body>
</html>
```
生成的java文件
```
public void _jspService(final javax.servlet.http.HttpServletRequest request, final javax.servlet.http.HttpServletResponse response)
      throws java.io.IOException, javax.servlet.ServletException {

    final java.lang.String _jspx_method = request.getMethod();
    if (!"GET".equals(_jspx_method) && !"POST".equals(_jspx_method) && !"HEAD".equals(_jspx_method) && !javax.servlet.DispatcherType.ERROR.equals(request.getDispatcherType())) {
      response.sendError(HttpServletResponse.SC_METHOD_NOT_ALLOWED, "JSPs only permit GET, POST or HEAD. Jasper also permits OPTIONS");
      return;
    }

    final javax.servlet.jsp.PageContext pageContext;
    javax.servlet.http.HttpSession session = null;
    final javax.servlet.ServletContext application;
    final javax.servlet.ServletConfig config;
    javax.servlet.jsp.JspWriter out = null;
    final java.lang.Object page = this;
    javax.servlet.jsp.JspWriter _jspx_out = null;
    javax.servlet.jsp.PageContext _jspx_page_context = null;


    try {
      response.setContentType("text/html;charset=UTF-8");
      pageContext = _jspxFactory.getPageContext(this, request, response,
      			"", true, 8192, true);
      _jspx_page_context = pageContext;
      application = pageContext.getServletContext();
      config = pageContext.getServletConfig();
      session = pageContext.getSession();
      out = pageContext.getOut();
      _jspx_out = out;

      out.write("\n");
      out.write("<html>\n");
      out.write("<head>\n");
      out.write("    <title>WelCome JSP</title>\n");
      out.write("</head>\n");
      out.write("\n");
      out.write("<body>\n");
      out.write("Welcome to Java Web.Hello~\n");
      out.write("\n");
      out.write("<br/>\n");
      out.write("\n");
      out.write("<!-- html注释内容-->\n");
out.println(new java.util.Date());
      out.write('\n');

//将count 值输出
out.println(count++);

      out.write("\n");
      out.write("<br/>\n");
      out.print(count++);
      out.write("\n");
      out.write("<br/>\n");

//将info 输出
out.println(info());

      out.write("\n");
      out.write("</body>\n");
      out.write("</html>");
    } catch (java.lang.Throwable t) {
      if (!(t instanceof javax.servlet.jsp.SkipPageException)){
        out = _jspx_out;
        if (out != null && out.getBufferSize() != 0)
          try {
            if (response.isCommitted()) {
              out.flush();
            } else {
              out.clearBuffer();
            }
          } catch (java.io.IOException e) {}
        if (_jspx_page_context != null) _jspx_page_context.handlePageException(t);
        else throw new ServletException(t);
      }
    } finally {
      _jspxFactory.releasePageContext(_jspx_page_context);
    }
  }
```
## JSP注释：
jsp注释：`<%-- 注释内容 --%>`
html注释：`<!-- html注释内容-->`
java注释：`//将count 值输出` 
通过查看生成的java文件和html源码，jsp注释只会出现在jsp文件中，html注释会被输出到浏览器的html源码中，java注释只会出现在生成的java文件中。

## JSP 声明：
<%! 声明部分 %>
JSP声明会被生成为java文件的成员变量和成员函数，用来声明变量和函数
JSP页面会被编译成一个Servlet类，每个Servlet类在容器中只有一个实例；


## JSP输出表达式：
<%=表达式%>(输出表达式语法后不能有分号)
对应生成的Java语句为`out.print(表达式)`



## JSP小脚本
<%
//将info 输出
out.println(info());
%>
JSP小脚本里可以包含任何可执行的Java代码。
JSP小脚本里声明的变量是Service函数里的局部变量

# JSP的3个编译指令
## page
<%@page ... %>该指令是针对当前页面的指令
page指令通常位于jsp页面的顶端，一个jsp页面可以使用多条page指令，格式如下：
```
<%@page
[language="java"]
[extends="package.class"]
[import="package.class|package.*,..."]
[session="true|false"]
[buffer="none|8KB|size Kb"]
[autoFlush="true|false"]
[isThreadSafe="true|false"]
[info="text"]
[errorPage="relativeURL"]
[contentType="text/html;charset=UTF-8"]
[pageEncoding]
[isErrorPage="true|false"]
%>
```
### language
声明当前JSP页面使用的脚本语言的种类，因为页面是JSP页面，该属性的值通常都是java，默认值也是java，通常无须设置。
### extends
指定jsp页面编译产生类所继承的父类或所实现的接口
### import
用来导入包。下面是默认导入的包名
java.lang.*,javax.servlet.*,javax.servlet.jsp.*,javax.servlet.http.*
### session
设定这个JSP是否需要http session
### buffer
指定缓冲区的大小，输出缓冲区的JSP内部对象：out用于缓存JSP页面对客户浏览器的输出，默认为8Kb，可以设为none，或其他值，单位为kb。
### autoFlush
当输出缓冲区即将溢出时，是否强制输出缓冲区内容。false会在溢出时产生一个异常。
### info
该JSP的信息，通过Servlet.getServletInfo()方法可以获取，如果是在jsp页面中，可以直接调用getServletInfo()
### errorPage
指定错误处理页面
### isErrorPage
设定本页面是否为错误处理程序。
### contentType
设定生成网页的文件格式和编码字符集,及MIME类型和页面字符集类型。
默认MIME为text/html，默认字符集为”ISO-8859-1“
### pageEncoding
生成网页的编码字符集





## include
可以将一个外部文件嵌入到当前JSP文件中，同时解析这个页面中的JSP语句。这是个静态的include语句，它会把目标页面的其他编译指令也包含进来，如果两个页面的编译指令冲突就会报错，如果是动态include则不会。
<%@include file="relativeURLSpec">
如果被嵌入的文件经常需要改变，建议使用<jsp:include>操作指令，这个是动态的include语句。

## taglib
用于定义和访问自定义标签

# 7个动作指令
## jsp:forward
执行页面转向，将请求的处理转发到下一个页面
JSP 1.0
<jsp:forward page="{relativeURL}<%=expression%>"/>
JSP 1.1
<jsp:forward page="{relativeURL}<%=expression%>">
  {<jsp:param.../>}
</jsp:forward>

```
<!--表单-->
a.jsp:
<form id="login" method="post" action="jsp-forward.jsp">
<input type="text" name="username">
<input type="submit" value="login">
</form>

jsp-forward.jsp:
<jsp:forward page="forward-result.jsp">
    <jsp:param name="age" value="29"/>
</jsp:forward>

forward-result.jsp:
<%=request.getParameter("age")%>
```
生成的java代码如下：
```
 if (true) {
  _jspx_page_context.forward("forward_result.jsp" + "?" + org.apache.jasper.runtime.JspRuntimeLibrary.URLEncode("age", request.getCharacterEncoding())+ "=" + org.apache.jasper.runtime.JspRuntimeLibrary.URLEncode("29", request.getCharacterEncoding()));
        return;
}
```
增加的参数可以通过HttpServletRequest类的getParameter（）方法获取，JSP中是request内置对象。
- 执行forward后页面的地址不会变化
- 执行forward指令转发请求时，客户端的请求参数不会丢失。


## jsp:param
用于传递参数，必须与其他支持参数的标签一起使用
与jsp:inclued,jsp:forward,jsp:plugin一起使用
## jsp:include
用于动态包含一个JSP页面
不会导入被include页面的编译指令，仅仅导入body内容

```
<jsp:include page="{relativeURL|<%=expression%>}" flush="true"/>
或
<jsp:include page="{relativeURL|<%=expression%>}" flush="true">
  <jsp:param name="parameterName" value="value"/>
</jsp:include>
```
flush 指定输出缓存是否转移到被导入文件中。JSP 1.1之前只能为false
动态导入只是使用一个include方法来插入目标页面的内容，而不是将目标页面完全融入本页面中。
```
...
org.apache.jasper.runtime.JspRuntimeLibrary.include(request,response,"scriptlet.jsp",out,false)
```
动态导入和静态区别：
- 是否完全融合
- 是否导入编译指令
- 是否可以增加额外参数


## jsp:plugin
用于下载服务器端的JavaBean或Applet到客户端执行


## jsp:useBean jsp:setProperty jsp:getProperty

- jsp:useBean：创建一个JavaBean的实例
- jsp:setProperty：设置JavaBean实例的属性值
- jsp:getProperty：输出JavaBean实例的属性值
  
<jsp:useBean id="name" class="classname" scope="page|request|session|application"/>
id:JavaBean的实例名，class 实现类，scope实例的作用范围有下面几个
- page：该JavaBean仅在该页面有效
- request：仅本次请求有效
- session：本次session有效
- application：本应用内一直有效

<jsp:setProperty name="BeanName" property="propertyName" value="Value" />

<jsp:getProperty name="BeanName" property="propertyName" />
当页面使用setProperty和getProperty标签时，系统底层就是调用setName()和getName()方法来操作Person实例的属性。

# JSP中的9个内置对象

这9个内置对象都是Serlet API接口的实例，他们已经是对象，可以直接使用

## application
javax.servlet.ServletContex 实例，代表JSP所属的Web应用本身，可用于JSP页面，或者Servlet直接交换信息，常用的方法有getAttribute（String attName），setAttribute（String attName，String attValue）和getInitParameter（String paramName），整个Web应用有效。
### 让多个JSP、Servlet共享数据
getAttribute（String attName），setAttribute（String attName，String attValue
### 获得Web应用配置参数
获取web.xml中的使用context-param元素配置的信息，每个<context-param...\>
```
<context-param>
  <param-name>driver</param-name>
  <param-value>com.mysql.jdbc</param-value>
</context-param>
```
application.getInitParemeter("driver")

## config
javax.servlet.ServletConfig 实例，代表JSP的配置信息
getInitParameter（String paramName），getInitParameterNames()
但JSP页面通常无须配置，因此JSP页面比较少用，但在Servlet中用处较大，因为Servlet需要在web.xml中配置.例如下面的配置：
```
<servlet>
  <servlet-name>config</servlet-name>
  <jsp-file>/configTest.jsp</jsp-file>//指定将哪个JSP页面配置成servlet
  <init-param>
    <param-name>name</param-name>
    <param-value>Crazy</param-value>
  </init-param>
</servlet>
<servlet-maping>
//指定将config servlet配置到/config路径
  <servlet-name>config</servlet-name>
  <url-patern>/config</url-parttern>
</servlet-maping>
```
如果希望JSP页面可以获取web.xml配置文件中的配置信息，则必须通过为该JSP配置的路径来访问该页面。
## exception
java.lang.Throwable实例，只有编译指令isErrorPage为true才可以使用。
getMessage（），printStackTrac（）
jsp声明需要自己处理exception

## out
javax.servlet.jsp.JspWriter实例，输出流

## page
代表该页面本身，即this，能用page的地方就可以用this。

## pageContext
javax.servlet.jsp.PageContext实例，代表该JSP的页面上下文，使用该对象可以访问页面中的共享数据。getServletContext（），getServletConfig（）。仅当前页面有效。
代表页面上下文，主要用于访问JSP之间共享的数据。可以访问page、request、session、application范围的变量。
```
getAttribute(String name):取得page范围内的name属性
getAttribute(String name,int scope):scope可以取：
PageContext.PAGE_SCOPE
PageContext.REQUEST_SCOPE
PageContext.SESSION_SCOPE
PageContext.APPLICATION_SCOPE
setAttribute(String name,value,scope)
```

## request
javax.servlet.HttpServletRequest实例。仅本次请求有效。
### 获取请求头/请求参数
### 操作request范围的属性
### 执行forward或include
HttpServletRequest类提供了一个getRequestDispatcher(String path)方法，其中path就是希望foward或者include的目标路径。
getRequestDispatcher("/a.jsp").include(request,response)
getRequestDispatcher("/a.jsp").forward(request,response)
## response
javax.servlet.HttpServletResponse实例

## session
代表一次会话,仅一次会话有效。
```
  public void _jspService(final javax.servlet.http.HttpServletRequest request, final javax.servlet.http.HttpServletResponse response)
      throws java.io.IOException, javax.servlet.ServletException {

    final java.lang.String _jspx_method = request.getMethod();
    if (!"GET".equals(_jspx_method) && !"POST".equals(_jspx_method) && !"HEAD".equals(_jspx_method) && !javax.servlet.DispatcherType.ERROR.equals(request.getDispatcherType())) {
      response.sendError(HttpServletResponse.SC_METHOD_NOT_ALLOWED, "JSPs only permit GET, POST or HEAD. Jasper also permits OPTIONS");
      return;
    }

    final javax.servlet.jsp.PageContext pageContext;
    javax.servlet.http.HttpSession session = null;
    final javax.servlet.ServletContext application;
    final javax.servlet.ServletConfig config;
    javax.servlet.jsp.JspWriter out = null;
    final java.lang.Object page = this;
    javax.servlet.jsp.JspWriter _jspx_out = null;
    javax.servlet.jsp.PageContext _jspx_page_context = null;


    pageContext = _jspxFactory.getPageContext(this, request, response,
      			"", true, 2048, true);
     _jspx_page_context = pageContext;
    application = pageContext.getServletContext();
    config = pageContext.getServletConfig();
    session = pageContext.getSession();
    out = pageContext.getOut();
```
# servlet
JSP本质就是Servlet，编写好的JSP页面部署到Web容器中之后，Web容器会将JSP编译成对应的Servlet。
Servlet是标准的Java类。
Sevlet是一个特殊的Java类，必须继承HttpServlet类。
每个Servlet可以响应客户端的请求：GET，POST，PUT，DELETE
处理什么请求就重写对应的doGet，doPost，doPut，doDelete函数，如果所有响应处理方式一致，可以直接重写service（）方法。
HttpServlet还包含：
init(ServletConfig config):创建Servlet时，初始化Servlet资源
destroy(）:销魂时调用
